# AGENTS.md
# Repository guidance for agentic contributors

## Scope
- This repo contains a SystemVerilog RTL module in `rtl/` and a C++ harness in `cpu_2601.cpp`.
- `builddir/` contains Verilator-generated artifacts. Treat it as generated output.
- There are no existing Cursor or Copilot rules in this repository.

## Build, Lint, Test Commands

### Build System (Preferred)
Use the repo build script at the root. It wraps Verilator and produces the simulation executable.

Build:
- `./build build`

Clean:
- `./build clean`

Notes:
- Output executable: `builddir/cpu_2601`.
- The script accepts optional overrides for Verilator root and toolchain binaries. See `build` for argument order.
- Keep generated outputs in `builddir/` only.

### Lint
There is no repository-wide lint config. Use Verilator lint for RTL:
- `verilator --lint-only -Wall rtl/cpu_2601.sv`

### Tests
There is no test framework or testbench in this repo.
- The C++ harness in `cpu_2601.cpp` serves as the only simulation driver.
- Single-test command: not applicable (document one if tests are added).

## Project Layout
- `rtl/` : SystemVerilog source code
- `cpu_2601.cpp` : C++ simulation harness
- `builddir/` : Verilator outputs (generated)

## Generated Artifacts (Do Not Edit)
- All files under `builddir/` are generated by Verilator.
- Do not hand-edit files like `Vcpu_2601.mk`, `Vcpu_2601*.cpp`, or `Vcpu_2601*.h`.
- Regenerate instead of editing generated files.

## Build Script Style Guidelines

### General Structure
- Use `#!/usr/bin/bash` shebang.
- Enable fail-fast behavior with `set -e` at the top.
- Organize code with `##` section headers: DIRECTORIES, BINS, FLAGS, FILES, HELPERS, BUILD, OPERATION.
- Place main execution logic at the bottom of the script.

### Naming Conventions
- **Variables**: `UPPER_SNAKE_CASE` for all constants and configuration.
  - Use semantic suffixes: `_DIR`, `_ROOT`, `_FLAGS`, `_BIN`, `_NAME`, `_OUT`.
  - Use prefixes to group related variables: `TOP_*`, `SIM_*`, `VERILATOR_*`.
- **Functions**: `snake_case` (lowercase with underscores).
  - Use verbs or verb phrases describing the action.

### Variable Usage
- Always quote variables: `"$VAR"`.
- Use parameter expansion for defaults: `${N:-default}`.
- Define all variables at the top in organized sections before functions.
- Build complex values through composition: `TOP_OUT_ALL="$BUILD_DIR/$TOP_OUT_ALL_NAME"`.
- No inline literal values; everything goes through a named variable, even tool binaries.

### Path Building
- Start with base paths: `CWD=$(pwd)`, `VERILATOR_ROOT`.
- Build derived paths using concatenation: `"$BASE/subdir"`.
- All paths constructed from variables, no hardcoded paths.
- Maintain hierarchical structure: derived paths depend on base paths.

### Flag Management
- **Complex flags in variables**: Define all tool flags in the FLAGS section at top.
  - Example: `VERILATOR_FLAGS="-I$RTL_DIR --Mdir $BUILD_DIR --cc"`
  - Example: `CXX_FLAGS="-std=c++17 -I$VERILATOR_INCLUDE -I$BUILD_DIR -O3"`
- **Minimal structural flags inline**: Only simple syntax flags like `-f`, `-C`, `-o` allowed inline.
- Rationale: Keeps configuration centralized and functions focused on workflow, not settings.

### Functions
- Use `function` keyword: `function name() {`.
- Opening brace on same line as function declaration.
- Use explicit returns: `return 0` for success, `return 1` for failure.
- Single responsibility: each function does one clear thing.

### Indentation and Formatting
- Indentation: 4 spaces (not tabs).
- Blank lines between function definitions.

### Quoting and Safety
- Quote all variable expansions: `"$VAR"`.
- Quote all path variables to handle spaces.

### Error Handling and Logging
- Use custom `raise` function for errors with descriptive messages.
- Consistent logging pattern:
  - `log` for primary messages.
  - `followup_log` (with `-->` prefix) for sub-messages.
  - `lnbreak` for blank lines instead of raw `echo ""`.

### Conditionals
- Use `[ ... ]` test syntax with proper spacing.
- Use `==` for string comparison.
- Check conditions with helper functions (e.g., `check_dir`).

### Comment Usage
- **Section headers only**: Use `## SECTION_NAME` to organize code blocks.
- **Minimal inline comments**: Only where absolutely necessary (e.g., documenting argument options).
- **Self-documenting code**: Choose function and variable names that eliminate the need for comments.
- **No function documentation blocks**: The name says it all.
- **No implementation comments**: Code inside functions should have zero comments.
- Philosophy: clear names eliminate the need for comments.

### Helper Philosophy
- Extract repeated logic into helper functions.
- Keep helpers at the top, main build logic functions in the middle, execution at bottom.

## SystemVerilog Style Guidelines

### General
- Use `logic` for signals unless a specific net type is required.
- Prefer explicit module ports and named port connections.
- Avoid implicit nets (no undeclared wires).
- Keep one primary module per file.
- Prefer `always_ff`/`always_comb` over `always` when applicable.
- Keep combinational logic free of latches; use defaults in `always_comb`.

### Formatting
- Indentation: 4 spaces in `rtl/cpu_2601.sv`.
- Align port lists vertically when they grow beyond a few lines.
- Keep blank lines between logical sections (ports, declarations, always blocks).
- Use trailing commas in multi-line port lists for easier diffs.

### Naming
- Module names: `snake_case` to match `cpu_2601`.
- Signals: `snake_case` with suffixes like `_n` for active-low signals.
- Parameters: `UPPER_SNAKE_CASE`.
- Localparams: `UPPER_SNAKE_CASE`.
- Use `_d`/`_q` suffixes for registered signals when helpful.

### Resets and Clocks
- Use clear names like `clk` and `rst` for top-level signals.
- If using active-low reset, name it `rst_n` and document behavior.

### Verilator Pragmas
- Use `/* verilator lint_off ... */` sparingly and only around known false positives.
- Re-enable lint with `/* verilator lint_on ... */` immediately after the block.

## C++ Style Guidelines (Simulation Harness)

### General
- Keep the harness minimal and deterministic.
- The harness currently toggles `clk` and calls `eval()` in a loop.
- Use `Verilated::commandArgs(argc, argv);` at startup.
- Avoid hidden global state; keep all simulation state in `main`.
- Prefer explicit time/step counters when adding cycle-based checks.

### Includes
- Include the generated model header first, then `verilated.h`:
  - `#include "Vcpu_2601.h"`
  - `#include "verilated.h"`
- Keep includes minimal; add only what the harness uses.

### Formatting
- Indentation: 2 spaces in `cpu_2601.cpp`.
- Braces on the same line as the statement.
- Prefer early returns for simple error handling.

### Ownership
- Allocate the model with `new` and free with `delete`.
- Avoid global state; keep simulation state in `main` or a small helper.
- If you add helpers, keep them in the same file unless they grow beyond scope.

## Error Handling
- Fail fast in the harness if required arguments are missing.
- Avoid empty catch blocks. Prefer explicit error messages.
- Print errors to stderr and return non-zero exit codes.

## Adding New Files
- Add new RTL files under `rtl/`.
- Update the `build` script to pass additional RTL sources to Verilator.
- Keep generated files in `builddir/` only.

## Suggestions for Future Expansion
- Add a testbench directory (e.g., `tb/`) and document single-test commands.
- Consider a simple `Makefile` at repo root to wrap Verilator commands.

## Quick Start (Typical Flow)
1. Edit `rtl/cpu_2601.sv`.
2. Build with the repo script:
   - `./build build`
3. Run the simulation executable:
   - `./builddir/cpu_2601`
